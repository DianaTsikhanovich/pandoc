# Лабораторная работа №4

## Продвинутая командная работа с Git

## Что такое fast-forward
В этой теме рассказывается о подходах к работе с ветками в команде. А именно: в какой момент
создаются ветки, когда они сливаются друг с другом, какие коммиты и в какую ветку попадают.
Чтобы разобрать плюсы и минусы реально используемых подходов, сначала объясним, чем плох
простой и очевидный подход «все дружно „пушим“ в main по очереди!». Для этого понадобится рассмотреть понятие fast-forward (англ. «перемотка вперёд») и его связь с git push. Начну с fast-forward: что это такое и как его распознать.

## Состояние fast-forward
Две ветки находятся в состоянии fast-forward, если одну из них можно «перемотать» вперёд, и она будет содержать те же коммиты, что и другая. 
Это утверждение можно сформулировать иначе:
- при слиянии этих двух веток никак не возможен конфликт;
- истории этих двух веток не «разошлись»;
- одна ветка является продолжением другой.

Разберём на примере. Есть две ветки: **main** и **add-docs** (англ. *«добавить документацию»*). В ветке **main** четыре коммита, от неё создали ветку **add-docs** и добавили в неё ещё два коммита.

```
$ git branch
* add-docs
main

$ git log --oneline
e08fa2a (HEAD -> add-docs) New docs 2
fd588b2 New docs 1
997d9ce (main) Commit 4
0313e8e Commit 3
5848aba Commit 2
04923d7 Commit 1
```

## Можно ли отключить fast-forward

Fast-forward слияние веток можно отключить флагом --no-ff. Например: git merge --no-ff add-docs. Также его можно отключить «навсегда» (до тех пор, пока вы не вернёте настройку «как было») c помощью настройки merge.ff: git config [--global] merge.ff false.
Если отключить слияние в режиме fast-forward, вместо «перемотки» ветки Git создаст в ней
коммит слияния (англ. merge commit) — в обиходе его называют **merge-коммит** или **мёрж-коммит**.

## Non-fast-forward
В прошлом уроке я поближе познакомился с состоянием fast-forward. Теперь покажу, что
происходит при объединении двух веток, коммиты которых нельзя выстроить в одну цепочку.
## Состояние non-fast-forward 
Вернёмся к примеру с ветками *main* и *add-docs* и представим такую ситуацию: истории двух веток «разошлись». Это значит, что их коммиты уже нельзя выстроить в одну линию.
Например, после «отделения» *add-docs* в ветку *main* добавили новый коммит Commit 5.

```
# команде git log можно указать несколько веток,
# и тогда она выведет их все
$ git log --graph --oneline main add-docs
* 15d3f04 (HEAD -> main) Commit 5
| * 8de42eb (add-docs) New docs 2
| * 4d3c346 New docs 1
|/
* 73def1e Commit 4
* 9c30ab3 Commit 3
* 83cc5ec Commit 2
* 8e87fb2 Commit 1
```

Когда Git проверяет ветки на состояние fast-forward, он не «заглядывает» в файлы и не пытается угадать, будет ли конфликт на самом деле. Для Git важно только, что конфликт теоретически возможен (или, наоборот, никак не возможен).
При слиянии не-fast-forward веток Git создаёт коммит слияния.

```
# находимся в ветке main
# --no-edit избавляет от необходимости
# вводить сообщение для merge-коммита
$ git merge --no-edit add-docs
Merge made by the 'ort' strategy.
docs.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 docs.txt
# коммит слияния: 34f5f8f
$ git log --graph --oneline
* 34f5f8f (HEAD -> main) Merge branch 'add-docs'
|\
| * 8de42eb (add-docs) New docs 2
| * 4d3c346 New docs 1
* | 15d3f04 Commit 5
|/
* 73def1e Commit 4
* 9c30ab3 Commit 3
* 83cc5ec Commit 2
* 8e87fb2 Commit 1
```

# Pull request и code review
В прошлом уроке рассказали о подходе Feature Branch Workflow, в котором вся новая
функциональность разрабатывается в feature-ветках. Как только «фича» готова, ветка вливается в main.
Но перед тем, как влиться в main, ветка проходит разные проверки, в том числе изменения
просматривают другие участники команды. О таких проверках и пойдёт речь в этой теме.

## Pull (или merge) request

В большинстве команд новые функциональности и исправления попадают в main через **запрос на слияние** (англ. *pull request*, или *merge request*). Его так и называют — пул-реквест или мёрж-реквест.
В переводе с языка Git это значит: «Вот моя ветка, хочу «вмёржить» её в main».

# Работа с PR: практика
Теоретический урок позади, теперь покажем, как создавать пул-реквесты, как оставлять к ним комментарии и как «апрувить» и «мёржить» PR в интерфейсе GitHub.
Представьте, что вы закончили разработку новой функциональности и готовы влить эти изменения в основную ветку. Но сначала вам нужно создать запрос на слияние, попросить коллег оценить вашу работу и, возможно, внести какие-то правки по их комментариям. Вместе с нами вы прослежу типичный цикл жизни PR.
В примерах буду использовать этот [репозиторий](https://github.com/andrewbudo/git-course-pr-example): создам в нём пул-реквест, пройду ревью и «вмёржу» изменения в main.
## Создаём пул-реквест
Участник проекта, пользователь b490 делает следующее:
1. Клонирует репозиторий.
2. Создаёт ветку feature-goose-poem.
3. Создаёт пул-реквест. Для этого используется ссылка, которую GitHub выводит через Git в консоль после выполнения команды git push.

## Проводим ревью
Теперь покажем, как другой участник проекта проводит ревью.
Ревьюер:
1. Заходит в пул-реквест и просматривает изменения.
2. Добавляет комментарии к тому, что кажется ему важным.
3. Выносит вердикт Request changes (англ. «нужны исправления»).

## Вносим исправления

Автор пул-реквеста видит, что ему предложили внести исправления, и приступает к работе.
Гуси становятся серым и белым — как положено. Пробелы в конце строк исправляют маркдаун-
разметку. Затем правки «коммитятся» и «пушатся» в ту же ветку — теперь в ней три коммита.

## «Апрувим» пул-реквест
Если ревьюера всё устраивает, он выносит вердикт Approve (англ. «одобрить»).
Отметим, что после одобрения кнопка **Merge pull request** появилась как у автора пул-реквеста, так и у ревьюера, потому что они оба участники проекта, или коллабораторы.

## Вливаем в main 
Когда ревью пройдено, автор пул-реквеста может нажать кнопку **Merge pull request**, а затем
**Confirm merge** (англ. «подтвердить объединение»). После нажатия этих кнопок GitHub вольёт ветку *feature-goose-poem* в *main*.
GitHub вливает ваши изменения в ветку main в origin, а локальная ветка остаётся как была. После «мёржа» PR рекомендуем обновить локальную main: git checkout main && git pull.
### Отличия для неучастников
Здесь показан типичный цикл жизни PR для разработки «в компаниях». Разве что обычно в таком цикле нет гусей.
В open-source проектах автор пул-реквеста, скорее всего, не будет участником (collaborator)
проекта. 

# Работа с PR: soft skills
Навыки специалиста принято делить на две группы: **hard skills** (англ. «жёсткие навыки») и **soft skills** (англ. «мягкие навыки», «гибкие навыки»).
- **Hard skills**, или **хардскилы**, — это владение инструментами, причём неважно какими. Умение забивать гвозди молотком, знание команд Git, умение играть на пианино — всё это примеры хардскилов. Именно этому типу навыков мы уделяли больше внимания в нашем курсе.
- **Soft skills**, или **софтскилы**, — это социально-психологические навыки. Например: умение договариваться, умение внятно донести свои мысли или понять идеи собеседника, умение мягко преподнести критику результатов работы.

# Разрешение конфликта вручную и через vimdiff
В этой теме поговорим о **конфликтах слияния**. Они могут случиться при слиянии веток (merge), если один и тот же файл был изменён в обеих ветках. Git не может сам решить, какая версия файла «правильная», а какая нет.
Такие конфликты нередко возникают в командной работе. В этом уроке покажем, как разрешать их вручную и через консоль.

## Подготавливаем репозиторий и создаём конфликт 
Подготовил новый Git-репозиторий.
```
$ mkdir git-conflict && cd git-conflict && git init
# создаём папку, переходим в неё, инициализируем новый Git-репозиторий
$ echo 'main version' > readme.md && git add . && git commit -m 'main'
# добавляем текст 'main version' в файл readme.md, делаем коммит
$ git checkout -b br1 && echo 'version 1' > readme.md && git add . && git commit -m 'v1'
# переходим в ветку br1 из основной ветки. Изменяем текст на 'version 1', делаем коммит
$ git checkout main
# возвращаемся в основную ветку
$ git checkout -b br2 && echo 'version 2' > readme.md && git add . && git commit -m 'v2'
# переходим в ветку br2 из основной ветки. Изменяем текст на 'version 2', делаем коммит
```
![image](https://github.com/HASK3R/First-project/assets/93817829/45e20138-c307-43a4-8899-f1f59dca401b)

![image](https://github.com/HASK3R/First-project/assets/93817829/2a1c4699-bb72-4302-9c98-5a4101944a00)

![image](https://github.com/HASK3R/First-project/assets/93817829/0fde541d-0137-416b-990d-2945e2f4812d)

![image](https://github.com/HASK3R/First-project/assets/93817829/d2b03629-efad-477d-b07a-516b0f2c7b96)


Добавьте в основную ветку (main или master) ветку br1. Коммиты этих веток можно выстроить в одну линию, поэтому слияние будет выполнено в режиме fast-forward.
Теперь в файле readme.md содержится текст version 1, а текущее состояние веток будет такое.
Настало время создать конфликт! Для этого убедитесь, что находитесь в основной ветке, а затем выполните git merge. 
Поздравляем: конфликт получен!
### Разрешаем конфликт вручную
Когда Git выявляет конфликт, он помечает проблемные файлы и останавливает процесс слияния.

При попытке объединить ветки или применить изменения из удалённого репозитория Git добавит в файлы специальные маркеры конфликта. Убедитесь в этом. Откройте файл readme.md в графическом интерфейсе или выполните cat readme.md.

Git разметил файл. Получившиеся секции содержат изменения из каждой ветки:
- Текст между <<<<<<< HEAD и ======= указывает на изменения, которые находятся в HEAD — в данном случае это ветка main. Здесь окажутся только те строки, в которых есть конфликт.
- Текст между ======= и >>>>>>> br2 показывает на изменения, которые находятся в ветке br2.
Чтобы разрешить конфликт вручную, нужно открыть файл и выбрать, какие изменения оставить, а какие отбросить. Для этого следует удалить все маркеры и ненужные изменения и оставить нужные.
После разрешения конфликта файлы будут отмечены как решённые. Можно продолжить процесс
слияния или выполнить коммит изменений.
Допустим, нужно оставить текст version 2. Откройте файл readme.md и удалите все маркеры
конфликтов, а также строку version 1.

![image](https://github.com/HASK3R/First-project/assets/93817829/08d0ddb3-ced6-4a07-86e3-0fc6fcd6f1be)
![image](https://github.com/HASK3R/First-project/assets/93817829/d3fde772-f578-497e-aa02-b38e03fd257c)


Готово! Вы разрешили конфликт вручную и создали коммит слияния. Теперь в файле readme.md
содержится текст version 2. Дерево коммитов будет выглядеть так.

## Разрешение конфликта через Visual Studio Code
Эти способы помогают лучше понять, как взаимодействовать с конфликтами, но всё же в работе над реальными проектами чаще используются другие.
Например, большинство разработчиков предпочитают более удобные интерфейсы, чем у vimdiff.
Такие интерфейсы предлагают почти все современные среды разработки (англ. Integrated Development Environment, или IDE, «интегрированная среда разработки») — программы, в которых собраны инструменты для быстрой и эффективной работы над проектом.
В этом уроке покажем, как выглядят конфликты в среде разработки Visual Studio Code (или
сокращённо VS code).

### Разрешаем конфликт с помощью VS Code
Разберём, какие инструменты предоставляет VS Code для разрешения конфликта. Но сперва снова сымитируйте его.

Удалите текущую папку git-conflict, которую создали в прошлом уроке. Затем пересоздайте её с помощью следующей команды.
Вы в одном шаге от конфликта! Но перед тем как создать его, откройте папку git-conflict в VS Code. Сделать это можно через меню File → Open... (для macOS) или Open Folder... (для Windows).
Откроется окно редактора.
Пришло время для конфликта! Выполните git merge br2 в консоли. Теперь в окне редактора
появятся маркеры конфликта.
Зелёным цветом подсвечивается текущая версия, а синим — новые изменения. Вы можете
разрешить конфликт прямо в файле вручную.
Нажмите на кнопку Resolve in Merge Editor (англ. «разрешить в редакторе слияний») в правом нижнем углу экрана.
Вы увидите окно разрешения конфликтов. Оно состоит из трёх частей: в левой части содержатся новые изменения, в правой — текущие, а в нижней — результат.
Используйте вспомогательные кнопки Accept Incoming (англ. «принять входящие»), Ignore (англ. «игнорировать») и Accept Current (англ. «принять текущие»), чтобы быстро добавить изменения в результат.
Щёлкните на Accept Incoming в левой верхней части экрана. Все конфликты разрешены, поэтому теперь можно нажать на Complete Merge (англ. «завершить слияние»).
Готово! Остался последний шаг — создать коммит слияния. VS Code попытается сделать это
автоматически в левой части экрана. Измените сообщение коммита, если нужно, и нажмите на кнопку Commit. Этот шаг также можно выполнить через консоль.

![image](https://github.com/HASK3R/First-project/assets/93817829/f24872c3-9780-4c4e-b2ae-9fc12ddd3798)
![image](https://github.com/HASK3R/First-project/assets/93817829/812cfca5-f180-47bf-9c00-e33fc47bff42)
![image](https://github.com/HASK3R/First-project/assets/93817829/c07d318c-8396-4c6b-bab2-2ca164063aad)

Задание для самостоятельной работы
1. Откройте этот архив. pushkin.zip
2. В архиве вы найдёте папку pushkin, в которой проинициализирован Git-репозиторий с тремя
ветками: main, version1 и version2. В ветках находятся разные версии стихотворения «К ***» («Я помню
чудное мгновенье...»), но в обеих версиях перепутаны местами строфы.
3. Соберите правильную версию стихотворения в ветке main. Для этого сначала перейдите в main,
сделайте git merge version1 из ветки main, а затем git merge version2. Помните, что иногда после
слияния вам необходимо удалить или добавить какие-то строки, чтобы получился корректный
результат, — это нормально.
4. Разрешите конфликт с помощью VS Code и выполните коммит слияния. Удачи!
![image](https://github.com/HASK3R/First-project/assets/93817829/1305fb6f-78ab-410c-b5d3-6aeae6feda43)
![image](https://github.com/HASK3R/First-project/assets/93817829/d1646b05-35c7-4616-bd23-58c2a082f928)
![image](https://github.com/HASK3R/First-project/assets/93817829/163879d7-b6c1-4d9b-a6f6-216fb3947678)
![image](https://github.com/HASK3R/First-project/assets/93817829/6a82b093-3636-4c33-a019-8529e146e32f)


## Шпаргалка. Командная работа в Git
Модуль подошёл к концу, а это значит, что пришло время подвести итоги и запастись шпаргалкой!
### Feature branch workflow
Самый популярный подход к работе с Git в команде — это feature branch workflow. В нём создают ветку для каждой задачи (например, для новой функциональности или исправления бага), а когда всё готово, вливают новую ветку в main.
Важные этапы этого процесса — пул-реквест и ревью изменений. Пул-реквест — это интерфейс, в котором можно обсудить изменения. Ревью — просмотр изменений другими участниками и один из способов проверить качество таких изменений.
Если вы уже участник проекта (или collaborator в терминах GitHub), можно клонировать
репозиторий напрямую. А если нет, нужно предварительно сделать «форк». Также для участников
доступна кнопка Merge после ревью, а для неучастников — нет.
### Конфликты слияния
Когда один и тот же файл меняется в нескольких ветках, при их слиянии может произойти
конфликт. Пугаться конфликтов не нужно, это нормальная часть работы с системами контроля версий. IDE, вроде VSCode или Intellij IDEA, помогут «склеить» файл из двух конфликтующих версий.

### Алгоритм-шпаргалка для создания PR
1. Склонировать репозиторий.

1.1. Если вы не участник проекта, предварительно сделать «форк» исходного репозитория.

1.2. На странице репозитория или «форка» нажать кнопки: Code → SSH → скопировать ссылку.

1.3. Выполнить команду git clone <ссылка на репозиторий>.

2. Создать ветку для вашей задачи: git checkout -b my-task-branch-name.

3. Добавить и «закоммитить» изменения, которые вы хотите внести в проект.

4. «Запушить» ветку: git push --set-upstream origin HEAD или git push -u origin my-task-branch-name.

4.1. GitHub (с помощью Git) выведет ссылку на создание PR. По ней нужно перейти.

4.2. PR можно также создать через интерфейс GitHub.

5. Сообщить о пул-реквесте ревьюеру.

5.1. Иногда ревьюеры назначаются автоматически, тогда сообщать не нужно.

6. Обсуждать с ревьюером предлагаемые изменения и вносить правки, пока эти изменения не будут
одобрены (пока не будет получен «апрув»).

6.1. Если кто-то добавил конфликтующие изменения в main, пока ваш PR был на ревью,
нужно разрешить конфликт:

o Обновить main: git checkout main && git pull.

o Влить main в свою ветку: git checkout my-task-branch-name && git merge main.

o Разрешить конфликты слияния с помощью IDE или вручную.

o Создать коммит слияния: git commit --no-edit или git commit -m 'merge main'.

o Сделать git push своей ветки.

7. Нажать кнопку Merge или подождать, пока её нажмёт кто-то ещё.

8. Ещё раз обновить main, чтобы «подтянуть» ваши изменения в основную ветку локального
репозитория: git checkout main && git pull.

9. Вы великолепны! Можете начинать снова со второго пункта.

### Алгоритм-шпаргалка для разрешения конфликтов слияния
1. Открыть проект в IDE (VS Code, IDEA или другие).
2. Открыть файл, в котором есть конфликт.
3. Выбрать, какие части файла нужно взять из одной ветки, а какие — из другой.
4. Когда конфликты разрешены, сделать коммит:
```
git commit --no-edit или git commit -m 'merge branch <название ветки>'.
```
Готово! Теперь вы можете приступать к работе над реальным проектом. Git будет вашим новым союзником!

